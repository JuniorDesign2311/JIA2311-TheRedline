export { formatFromStore, formatToStore } from 'json-storage-formatter';
import { clone } from 'json-storage-formatter';
import { useEffect, useState } from 'react';
const throwWrongKeyOnActionCollectionConfig = (action_key) => {
    throw new Error(`[WRONG CONFIGURATION!]: Every key inside the storeActionsConfig must be a higher order function that returns a function \n[${action_key}]: key is not a valid function, try something like this: \n{\n
    ${action_key}: (param) => ({ setState, getState, setMetadata, getMetadata }) => {\n
      setState((state) => ({ ...state, ...param }))\n
    }\n
}\n`);
};
/**
 * The GlobalStore class is the main class of the library and it is used to create a GlobalStore instances
 * @template {TState} TState - The type of the state object
 * @template {TMetadata} TMetadata - The type of the metadata object (optional) (default: null) no reactive information set to share with the subscribers
 * @template {TStateSetter} TStateSetter - The type of the setterConfig object (optional) (default: null) if a configuration is passed, the hook will return an object with the actions then all the store manipulation will be done through the actions
 * */
export class GlobalStore {
    /**
     * Create a new instance of the GlobalStore
     * @param {TState} state - The initial state
     * @param {GlobalStoreConfig<TState, TMetadata>} config - The configuration object (optional) (default: { metadata: null })
     * @param {GlobalStoreConfig<TState, TMetadata>} config.metadata - The metadata object (optional) (default: null) if not null the metadata object will be reactive
     * @param {GlobalStoreConfig<TState, TMetadata>} config.onInit - The callback to execute when the store is initialized (optional) (default: null)
     * @param {GlobalStoreConfig<TState, TMetadata>} config.onStateChanged - The callback to execute when the state is changed (optional) (default: null)
     * @param {GlobalStoreConfig<TState, TMetadata>} config.onSubscribed - The callback to execute when a new component gets subscribed to the store (optional) (default: null)
     * @param {GlobalStoreConfig<TState, TMetadata>} config.computePreventStateChange - The callback to execute everytime a state change is triggered and before the state is updated, it allows to prevent the state change by returning true (optional) (default: null)   * @param {TStateSetter} setterConfig - The actions configuration object (optional) (default: null) if not null the store manipulation will be done through the actions
     * */
    constructor(state, config = {}, setterConfig = null) {
        this.state = state;
        this.setterConfig = setterConfig;
        /**
         * list of all the subscribers setState functions
         * @template {TState} TState - The type of the state object
         * */
        this.subscribers = new Set();
        /**
         * additional configuration for the store
         * @template {TState} TState - The type of the state object
         * @template {TMetadata} TMetadata - The type of the metadata object (optional) (default: null) no reactive information set to share with the subscribers
         * @template {TStateSetter} TStateSetter - The type of the setterConfig object (optional) (default: null) if a configuration is passed, the hook will return an object with the actions then all the store manipulation will be done through the actions
         * @property {GlobalStoreConfig<TState, TMetadata, TStateSetter>} config.metadata - The metadata to pass to the callbacks (optional) (default: null)
         * @property {GlobalStoreConfig<TState, TMetadata, TStateSetter>} config.onInit - The callback to execute when the store is initialized (optional) (default: null)
         * @property {GlobalStoreConfig<TState, TMetadata, TStateSetter>} config.onStateChanged - The callback to execute when the state is changed (optional) (default: null)
         * @property {GlobalStoreConfig<TState, TMetadata, TStateSetter>} config.onSubscribed - The callback to execute when a component is subscribed to the store (optional) (default: null)
         * @property {GlobalStoreConfig<TState, TMetadata, TStateSetter>} config.computePreventStateChange - The callback to execute when the state is changed to compute if the state change should be prevented (optional) (default: null)
         */
        this.config = {
            metadata: null,
        };
        /**
         * execute once the store is created
         * @template {TState} TState - The type of the state object
         * @template {TMetadata} TMetadata - The type of the metadata object (optional) (default: null) no reactive information set to share with the subscribers
         * @template {TStateSetter} TStateSetter - The type of the setterConfig object (optional) (default: null) if a configuration is passed, the hook will return an object with the actions then all the store manipulation will be done through the actions
         * @param {StateConfigCallbackParam<TState, TMetadata, TStateSetter>} parameters - The parameters object brings the following properties: setState, getState, setMetadata, getMetadata
         * @param {Dispatch<SetStateAction<TState>>} parameters.setState - The setState function to update the state
         * @param {() => TState} parameters.getState - The getState function to get the state
         * @param {Dispatch<SetStateAction<TMetadata>>} parameters.setMetadata - The setMetadata function to update the metadata
         * @param {() => TMetadata} parameters.getMetadata - The getMetadata function to get the metadata
         * */
        this.onInit = null;
        /**
         * execute every time the state is changed
         * @template {TState} TState - The type of the state object
         * @template {TMetadata} TMetadata - The type of the metadata object (optional) (default: null) no reactive information set to share with the subscribers
         * @template {TStateSetter} TStateSetter - The type of the setterConfig object (optional) (default: null) if a configuration is passed, the hook will return an object with the actions then all the store manipulation will be done through the actions
         * @param {StateConfigCallbackParam<TState, TMetadata, TStateSetter>} parameters - The parameters object brings the following properties: setState, getState, setMetadata, getMetadata
         * @param {Dispatch<SetStateAction<TState>>} parameters.setState - The setState function to update the state
         * @param {() => TState} parameters.getState - The getState function to get the state
         * @param {Dispatch<SetStateAction<TMetadata>>} parameters.setMetadata - The setMetadata function to update the metadata
         * @param {() => TMetadata} parameters.getMetadata - The getMetadata function to get the metadata
         * */
        this.onStateChanged = null;
        /**
         * Execute each time a new component gets subscribed to the store
         * @template {TState} TState - The type of the state object
         * @template {TMetadata} TMetadata - The type of the metadata object (optional) (default: null) no reactive information set to share with the subscribers
         * @template {TStateSetter} TStateSetter - The type of the setterConfig object (optional) (default: null) if a configuration is passed, the hook will return an object with the actions then all the store manipulation will be done through the actions
         * @param {StateConfigCallbackParam<TState, TMetadata, TStateSetter>} parameters - The parameters object brings the following properties: setState, getState, setMetadata, getMetadata
         * @param {Dispatch<SetStateAction<TState>>} parameters.setState - The setState function to update the state
         * @param {() => TState} parameters.getState - The getState function to get the state
         * @param {Dispatch<SetStateAction<TMetadata>>} parameters.setMetadata - The setMetadata function to update the metadata
         * @param {() => TMetadata} parameters.getMetadata - The getMetadata function to get the metadata
         * */
        this.onSubscribed = null;
        /**
         * Execute everytime a state change is triggered and before the state is updated, it allows to prevent the state change by returning true
         * @template {TState} TState - The type of the state object
         * @template {TMetadata} TMetadata - The type of the metadata object (optional) (default: null) no reactive information set to share with the subscribers
         * @template {TStateSetter} TStateSetter - The type of the setterConfig object (optional) (default: null) if a configuration is passed, the hook will return an object with the actions then all the store manipulation will be done through the actions
         * @param {StateConfigCallbackParam<TState, TMetadata, TStateSetter>} parameters - The parameters object brings the following properties: setState, getState, setMetadata, getMetadata
         * @param {Dispatch<SetStateAction<TState>>} parameters.setState - The setState function to update the state
         * @param {() => TState} parameters.getState - The getState function to get the state
         * @param {Dispatch<SetStateAction<TMetadata>>} parameters.setMetadata - The setMetadata function to update the metadata
         * @param {() => TMetadata} parameters.getMetadata - The getMetadata function to get the metadata
         * @returns {boolean} - true to prevent the state change, false to allow the state change
         * */
        this.computePreventStateChange = null;
        this.onInitializeStore = () => {
            const { onInit } = this;
            const { onInit: onInitFromConfig } = this.config;
            if (!onInit && !onInitFromConfig)
                return;
            const parameters = this.getConfigCallbackParam({});
            onInit === null || onInit === void 0 ? void 0 : onInit(parameters);
            onInitFromConfig === null || onInitFromConfig === void 0 ? void 0 : onInitFromConfig(parameters);
        };
        /**
         * gets a clone of the state
         * @returns {TState} - The state clone
         * */
        this.getStateClone = () => clone(this.state);
        /**
         * gets a clone of the metadata
         * @returns {TMetadata} - The metadata clone
         * */
        this.getMetadataClone = () => { var _a, _b; return clone((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.metadata) !== null && _b !== void 0 ? _b : null); };
        /**
         * set the state and update all the subscribers
         * @param {StateSetter<TState>} setter - The setter function or the value to set
         * @param {React.Dispatch<React.SetStateAction<TState>>} invokerSetState - The setState function of the component that invoked the state change (optional) (default: null) this is used to updated first the component that invoked the state change
         * */
        this.setState = ({ invokerSetState, state, }) => {
            // update the state
            this.state = state;
            // execute first the callback of the component that invoked the state change
            invokerSetState === null || invokerSetState === void 0 ? void 0 : invokerSetState(state);
            // update all the subscribers
            this.subscribers.forEach((setState) => {
                if (setState === invokerSetState)
                    return;
                setState(state);
            });
        };
        /**
         * Set the value of the metadata property, this is no reactive and will not trigger a re-render
         * @param {StateSetter<TMetadata>} setter - The setter function or the value to set
         * */
        this.setMetadata = (setter) => {
            var _a;
            const isSetterFunction = typeof setter === 'function';
            const metadata = isSetterFunction
                ? setter(this.getMetadataClone())
                : setter;
            this.config = Object.assign(Object.assign({}, ((_a = this.config) !== null && _a !== void 0 ? _a : {})), { metadata });
        };
        /**
         * get the parameters object to pass to the callback functions (onInit, onStateChanged, onSubscribed, computePreventStateChange)
         * this parameters object brings the following properties: setState, getState, setMetadata, getMetadata
         * this parameter object allows to update the state, get the state, update the metadata, get the metadata
         * @param {{ invokerSetState?: React.Dispatch<React.SetStateAction<TState>> }} parameters - The setState function of the component that invoked the state change (optional) (default: null) this is used to updated first the component that invoked the state change
         * @returns {StateConfigCallbackParam<TState, TMetadata>} - The parameters object
         * */
        this.getConfigCallbackParam = ({ invokerSetState, }) => {
            const { setMetadata, getMetadataClone: getMetadata, getStateClone: getState, } = this;
            const setState = this.getSetStateWrapper({ invokerSetState });
            const actions = this.getStoreActionsMap({});
            return {
                setMetadata,
                getMetadata,
                getState,
                setState,
                actions,
            };
        };
        /**
         * Returns a custom hook that allows to handle a global state
         * @returns {[TState, TStateSetter, TMetadata]} - The state, the state setter or the actions map, the metadata
         * */
        this.getHook = () => () => {
            const [value, invokerSetState] = useState(() => this.state);
            useEffect(() => {
                this.subscribers.add(invokerSetState);
                const { onSubscribed } = this;
                const { onSubscribed: onSubscribedFromConfig } = this.config;
                if (onSubscribed || onSubscribedFromConfig) {
                    const parameters = this.getConfigCallbackParam({ invokerSetState });
                    onSubscribed === null || onSubscribed === void 0 ? void 0 : onSubscribed(parameters);
                    onSubscribedFromConfig === null || onSubscribedFromConfig === void 0 ? void 0 : onSubscribedFromConfig(parameters);
                }
                return () => {
                    this.subscribers.delete(invokerSetState);
                };
            }, []);
            const stateOrchestrator = this.getStateOrchestrator(invokerSetState);
            return [value, stateOrchestrator, this.getMetadataClone()];
        };
        /**
         * Returns an array with the a function to get the state, the state setter or the actions map, and a function to get the metadata
         * @returns {[() => TState, TStateSetter, () => TMetadata]} - The state getter, the state setter or the actions map, the metadata getter
         * */
        this.getHookDecoupled = () => {
            const { getStateClone: getState, getMetadataClone: getMetadata } = this;
            const stateOrchestrator = this.getStateOrchestrator();
            return [getState, stateOrchestrator, getMetadata];
        };
        /**
         * returns a wrapper for the setState function that will update the state and all the subscribers
         * @param {{ invokerSetState?: React.Dispatch<React.SetStateAction<TState>> }} parameters - The setState function of the component that invoked the state change (optional) (default: null) this is used to updated first the component that invoked the state change
         * @returns {StateSetter<TState>} - The state setter
         * */
        this.getSetStateWrapper = ({ invokerSetState, } = {}) => {
            const setState = (setter) => {
                this.computeSetState({ invokerSetState, setter });
            };
            return setState;
        };
        /**
         * Calculate whenever or not we should compute the callback parameters on the state change
         * @returns {boolean} - True if we should compute the callback parameters on the state change
         * */
        this.hasStateCallbacks = () => {
            const { computePreventStateChange, onStateChanged } = this;
            const { computePreventStateChange: computePreventStateChangeFromConfig, onStateChanged: onStateChangedFromConfig, } = this.config;
            const preventStateChangesCalls = computePreventStateChange || computePreventStateChangeFromConfig;
            const stateChangeCalls = onStateChanged || onStateChangedFromConfig;
            const shouldComputeParameter = preventStateChangesCalls || stateChangeCalls;
            return !!shouldComputeParameter;
        };
        /**
         * This is responsible for defining whenever or not the state change should be allowed or prevented
         * the function also execute the functions:
         * - onStateChanged (if defined) - this function is executed after the state change
         * - computePreventStateChange (if defined) - this function is executed before the state change and it should return a boolean value that will be used to determine if the state change should be prevented or not
         * @param {{ setter: StateSetter<TState>; invokerSetState?: React.Dispatch<React.SetStateAction<TState>> }} parameters - The state setter and the setState function of the component that invoked the state change (optional) (default: null) this is used to updated first the component that invoked the state change
         */
        this.computeSetState = ({ setter, invokerSetState, }) => {
            const isSetterFunction = typeof setter === 'function';
            const previousState = this.getStateClone();
            const newState = isSetterFunction
                ? setter(previousState)
                : setter;
            const itHasStateCallbacks = this.hasStateCallbacks();
            const actions = itHasStateCallbacks && this.getStoreActionsMap({});
            const setState = itHasStateCallbacks && this.getSetStateWrapper({ invokerSetState });
            const { setMetadata, getMetadataClone: getMetadata, getStateClone: getState, } = this;
            const callbackParameter = {
                setMetadata,
                getMetadata,
                setState,
                getState,
                actions,
                previousState,
                state: newState,
            };
            const { computePreventStateChange } = this;
            const { computePreventStateChange: computePreventStateChangeFromConfig } = this.config;
            // check if the state change should be prevented
            if (computePreventStateChange || computePreventStateChangeFromConfig) {
                const preventStateChange = (computePreventStateChange === null || computePreventStateChange === void 0 ? void 0 : computePreventStateChange(callbackParameter)) ||
                    (computePreventStateChangeFromConfig === null || computePreventStateChangeFromConfig === void 0 ? void 0 : computePreventStateChangeFromConfig(callbackParameter));
                if (preventStateChange)
                    return;
            }
            this.setState({
                invokerSetState,
                state: newState,
            });
            const { onStateChanged } = this;
            const { onStateChanged: onStateChangedFromConfig } = this.config;
            if (!onStateChanged && !onStateChangedFromConfig)
                return;
            onStateChanged === null || onStateChanged === void 0 ? void 0 : onStateChanged(callbackParameter);
            onStateChangedFromConfig === null || onStateChangedFromConfig === void 0 ? void 0 : onStateChangedFromConfig(callbackParameter);
        };
        /**
         * This creates a map of actions that can be used to modify or interact with the state
         * @param {{ invokerSetState?: React.Dispatch<React.SetStateAction<TState>> }} parameters - The setState function of the component that invoked the state change (optional) (default: null) this is used to updated first the component that invoked the state change
         * @returns {ActionCollectionResult<TState, TMetadata, TStateSetter>} - The actions map result of the configuration object passed to the constructor
         * */
        this.getStoreActionsMap = ({ invokerSetState, }) => {
            if (!this.setterConfig)
                return null;
            const { setterConfig, setMetadata } = this;
            const actionsConfig = setterConfig;
            const actionsKeys = Object.keys(actionsConfig);
            const setState = this.getSetStateWrapper({
                invokerSetState,
            });
            // we expose a copy of the state and metadata to the actions to prevent them from modifying the state directly
            const { getStateClone: getState, getMetadataClone: getMetadata } = this;
            // we bind the functions to the actions object to allow reusing actions in the same api config by using the -this- keyword
            const actions = actionsKeys.reduce((accumulator, action_key) => (Object.assign(Object.assign({}, accumulator), { [action_key](...parameres) {
                    const actionConfig = actionsConfig[action_key];
                    const action = actionConfig.apply(actions, parameres);
                    const actionIsNotAFunction = typeof action !== 'function';
                    // we throw an error if the action is not a function, this is mandatory for the correct execution of the actions
                    if (actionIsNotAFunction) {
                        throwWrongKeyOnActionCollectionConfig(action_key);
                    }
                    // executes the actions bringing access to the state setter and a copy of the state
                    const result = action.call(actions, {
                        setState,
                        getState,
                        setMetadata,
                        getMetadata,
                    });
                    // we return the result of the actions to the invoker
                    return result;
                } })), {});
            return actions;
        };
        this.config = Object.assign({ metadata: null }, (config !== null && config !== void 0 ? config : {}));
        this.onInitializeStore();
    }
    /**
     * Returns the state setter or the actions map
     * @param {{ invokerSetState?: React.Dispatch<React.SetStateAction<TState>> }} parameters - The setState function of the component that invoked the state change (optional) (default: null) this is used to updated first the component that invoked the state change
     * @returns {TStateSetter} - The state setter or the actions map
     * */
    getStateOrchestrator(invokerSetState) {
        const stateHasCustomActions = this.setterConfig;
        if (stateHasCustomActions) {
            return this.getStoreActionsMap({ invokerSetState });
        }
        return this.getSetStateWrapper({ invokerSetState });
    }
}
